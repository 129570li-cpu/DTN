"""
Manage time-varying node features for dynamic graph environments.
"""
from __future__ import annotations
import json
from typing import Dict, List, Iterator, Optional

class NodeFeatureTimeline:
    """
    Holds a sequence of node feature frames.
    Each frame is a Dict[node_id, feature_vector].
    """
    def __init__(self, frames: List[Dict[int, List[float]]], meta: Optional[dict] = None):
        self.frames = frames
        self.meta = meta or {}

    def num_frames(self) -> int:
        return len(self.frames)

    def frame(self, idx: int) -> Dict[int, List[float]]:
        """Get the feature dict for a specific time index."""
        if not self.frames:
            return {}
        # Clamp index to valid range
        idx = max(0, min(idx, len(self.frames) - 1))
        return self.frames[idx]

    def iter_frames(self) -> Iterator[Dict[int, List[float]]]:
        """Iterate over all frames in order."""
        for f in self.frames:
            yield f

def load_node_feature_timeline(path: Optional[str]) -> Optional[NodeFeatureTimeline]:
    """
    Load node features from a JSON file generated by build_node_features.py.
    Expected JSON structure:
    {
      "meta": {...},
      "nodes": {
        "node_id_str": [ [frame0_feats], [frame1_feats], ... ],
        ...
      }
    }
    """
    if not path:
        return None
    
    with open(path, "r") as f:
        data = json.load(f)

    # Check if this is the old format (Dict[str, List[float]]) or new format
    # Old format: {"0": [f1, f2...], "1": [...]} -> Single frame
    # New format: has "nodes" key, or values are List[List[float]]
    
    # Heuristic: check if "nodes" key exists (new format)
    if "nodes" in data and isinstance(data["nodes"], dict):
        raw_nodes = data["nodes"]
        meta = data.get("meta", {})
    else:
        # Fallback for old format or raw dict
        # If values are lists of floats, treat as single frame
        # If values are lists of lists, treat as multi-frame
        raw_nodes = data
        meta = {}

    if not raw_nodes:
        return NodeFeatureTimeline([], meta)

    # Determine number of frames from the first node
    first_key = next(iter(raw_nodes))
    first_val = raw_nodes[first_key]
    
    if not first_val:
        return NodeFeatureTimeline([], meta)

    # Check if it's a list of lists (multi-frame) or list of floats (single frame)
    is_multi_frame = isinstance(first_val[0], list)

    if not is_multi_frame:
        # Single frame: convert to one-frame timeline
        # data is Dict[str, List[float]]
        frame: Dict[int, List[float]] = {}
        for k, v in raw_nodes.items():
            frame[int(k)] = [float(x) for x in v]
        return NodeFeatureTimeline([frame], meta)

    # Multi-frame: convert Dict[str, List[List[float]]] -> List[Dict[int, List[float]]]
    num_frames = len(first_val)
    frames: List[Dict[int, List[float]]] = [{} for _ in range(num_frames)]
    
    for k, v_list in raw_nodes.items():
        nid = int(k)
        # Handle case where some nodes might have fewer frames (shouldn't happen with valid output)
        limit = min(len(v_list), num_frames)
        for i in range(limit):
            frames[i][nid] = [float(x) for x in v_list[i]]

    return NodeFeatureTimeline(frames, meta)
