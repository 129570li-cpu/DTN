算法名称：基于 Q 值排序的深度优先搜索 (Q-Guided DFS)
核心逻辑： 这是一个深度优先搜索 (DFS)，但它不是盲目地选路，而是根据 GNN 预测的 Q 值 从高到低尝试邻居。如果最高分的邻居走不通（死胡同），就自动回退尝试第二高分的，直到找到终点。

详细步骤：

初始化：
path = [起点]
visited = {起点} （防止走回头路）
dead_ends = {} （记录已知的死胡同）
递归搜索函数 search(current_node)：
终止条件：如果 current_node == 终点，返回 成功。
第一步：筛选邻居 (Masking)
获取所有邻居。
剔除那些已经在 visited 里的（防止死循环）。
剔除那些在 dead_ends 里的（防止重复尝试死路）。
如果没有邻居可选 -> 标记当前点为 dead_end，返回 失败（触发回溯）。
第二步：打分排序 (Ranking)
调用 GNN 模型，计算剩余所有邻居的 Q 值。
将邻居按 Q 值从大到小排序。
第三步：贪婪尝试 (Try Best)
遍历排序后的邻居列表：
将邻居加入 path 和 visited。
递归调用 search(邻居)。
如果递归返回 成功 -> 任务完成，直接返回。
如果递归返回 失败 -> 回溯 (Backtrack)：将邻居从 path 和 visited 中移除，继续尝试下一个邻居。
第四步：彻底失败
如果所有邻居都试过了都不行 -> 标记当前点为 dead_end，返回 失败。
优势：

既聪明又可靠：优先走模型认为最好的路；如果模型看走眼了，也能自动纠错，保证 100% 找到路径（只要路存在）。